# **1)**

```csharp
int a = 5;
int b = 6;
a = b;
b = 7;
Console.WriteLine(a);
```

### **Разбор**

1. `int a = 5;`

   * В стеке создаётся ячейка `a`.
   * В неё записывается значение `5`.

2. `int b = 6;`

   * Создаётся ячейка `b`.
   * В неё записывается `6`.

3. `a = b;`

   * Считывается значение из `b` (6).
   * Это значение копируется в ячейку `a`.
   * Теперь `a` содержит число `6`.

4. `b = 7;`

   * Ячейка `b` получает новое значение `7`.
   * На `a` это уже никак не влияет — копирование было одноразовым.

5. `Console.WriteLine(a);`

   * Печатает `6`.

### **Итог**

* В стеке: `a = 6`, `b = 7`.
* Динамическая память не используется (int — тип-значение).
* В консоль выводится:

```
6
```

---

# **2)**

```csharp
int a = 5;
int b = a + 6;
a = 7;
Console.WriteLine(b);
```

### **Разбор**

1. `a = 5` — создаётся ячейка `a`, записывается `5`.

2. `b = a + 6`

   * Вычисляется выражение:
     `a + 6` → `5 + 6` → `11`.
   * Создаётся ячейка `b`, туда записывается число `11`.

3. `a = 7`

   * Значение в `a` меняется на `7`.
   * `b` уже хранит готовое значение `11`, и оно не меняется.

4. `Console.WriteLine(b);`

   * Печатается `11`.

### **Итог**

* В стеке: `a = 7`, `b = 11`.
* Динамическая память не используется.
* В консоль выводится:

```
11
```

---

# **3)**

```csharp
string a = "1";
string b = a;
a = "2";
Console.WriteLine(a);
Console.WriteLine(b);
```

### **Разбор**

1. `string a = "1";`
   Делается 3 действия:

   * В стеке создаётся переменная `a`.
   * В хипе создаётся объект строки `"1"` (если ещё не создан в пуле строк).
   * В `a` записывается **адрес** этого объекта.

2. `string b = a;`

   * Создаётся переменная `b` в стеке.
   * В неё копируется **адрес** того же объекта `"1"`.
     То есть `a` и `b` указывают **на один объект** `"1"`.

3. `a = "2";`

   * Создаётся новый объект строки `"2"` (или используется из пула).
   * В `a` записывается новый адрес — указатель на `"2"`.
   * **Объект `"1"` остаётся привязанным к `b`.**

4. Печать:

   * `Console.WriteLine(a);` → `"2"`
   * `Console.WriteLine(b);` → `"1"`

### **Итог**

* В стеке:
  `a → "2"`,
  `b → "1"`.
* В хипе: 2 строковых объекта.
* Вывод:

```
2
1
```

---

# **4)**

```csharp
string a = 5;
```

### **Разбор**

* Тип `string` хранит **ссылки только на строковые объекты**.
* `5` — это `int`, не строка.
* Не существует неявного преобразования `int → string` в присваивании.

### **Итог**

Компиляционная ошибка: *"Cannot implicitly convert type 'int' to 'string'"*

---

# **5)**

```csharp
int a = 5;
int a = 6;
```

### **Разбор**

* Создание второй переменной `a` в той же области видимости невозможно.
* Переменную можно **только переопределить**:
  `a = 6;` — было бы корректно.
* Но повторное объявление приводит к ошибке.

### **Итог**

Ошибка компиляции: *"A local variable named 'a' is already defined in this scope"*
